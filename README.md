```
TODO: дополнить и структурировать README
```

<h3> Особенности архитектуры и CodeStyle </h3>

* Классы, соответствующие страницам приложения, наследуются от класса BasePage
* URL соответствующей страницы в этих классах указывается с помощью аннотации @Url над классом
* Названия классов страниц начинаются с "Page"
* Методы, отвечающие за взаимодействие со страницей используют Fluent API подход (возможность строить цепочки из методов)
* Классы тестов наследуются от класса BaseTest
* Взаимодействие страницы (сущности) с другими страницами (сущностями) проверяется в тестах, относящихся
к той странице (сущности), с которой происходит изменение (удаление, создание, редактирование и пр.).
```
Пример:
Если провод используется в тяговой сети и при этом удаляется или редактируется, то проверка происходит в тестах связанных с проводами и
рельсами, а не в тестах связанных с тяговыми сетями.
```
* Статический метод ```open(pageClass)``` доступен в классах, унаследованных от BasePage и BaseTest.
Этот метод позволяет перейти на страницу, указанную в аннотации @Url над классом, тип которого передан в аргумент метода.
Чтобы получить объект страницы без перехода по её адресу, используется метод ```Selenide.page(pageClass)```
* Статический метод ```urlOf(pageClass)``` доступен в классах, унаследованных от BasePage и BaseTest. Этот метод позволяет
получить url, указанный в аннотации @Url над классом, тип которого передан в аргумент метода
* Статический метод ```login(login, password)``` класса BaseTest открывает страницу авторизации и выполняет вход
с переданными логином и паролем. Если логин и пароль не переданы, выполняет вход под учетной записью тестового
пользователя с правом редактирования НСИ (на данный момент testnsi, захардкожено)
* Статический метод ```clickLogout()``` класса BasePage нажимает кнопку "Выйти"
* Статический метод ```also()``` класса BasePage - аналог котлиновского ```apply```
* Статический метод ```waitTime()``` класса BasePage - для ожидания прогрузки страницы
* Константы со значениями цветов для проверки цвета элементов при валидных/не валидных введенных данных хранятся в классе Colors
* Предпочтительный способ поиска элементов на странице - по аттрибуту ```data-testid```
* Для правильной интеграции с Qase необходимо проставлять аннотации ```@QaseId``` с ID кейса над методами
* Также, для корректной работы интеграции с Qase НЕ использовать `@Nested` аннотацию из JUnit


<h3> Входные данные для тестов </h3>
Лежат в формате csv, в каталоге ресурсов, в папке "csv" в кодировке UTF-8.

<h3> Запуск с интеграцией Qase </h3>

* необходимые флаги для запуска с maven:
  * `DQASE_ENABLE=true`
  * `DQASE_PROJECT_CODE=ASUTER`
  * `DQASE_RUN_NAME=ИМЯ_ТЕСТ_РАНА_ОТОБРАЖАЕМОГО_В_QASE`
  * `DQASE_RUN_AUTOCOMPLETE=true` при значении false тестран необходимо завершить вручную в Qase
  * `DQASE_SCREENSHOT_SENDING=true`
  * `DQASE_API_TOKEN=ТОКЕН`

В зависимости от версии JDK может возникнуть проблема с недоверием JVM к Qase и выбрасыванием SSL exception. Например
`sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target`.
В этом случае можно добавить сертификат Qase в JDK с помощью keytool (утилита в комплекте с JDK).
Также, возможно, понадобится запускать с флагом `Dcom.sun.security.enableAIAcaIssuers=true`

<h3>Замечание по нахождению элементов svg</h3>

Элементы `svg` стандартным xpath не находятся. Для них и всех вложенных в них элементов нужно использовать функции name(), 
например:
```
@FindBy(xpath = "//div[@id=\"rootContainer\"]/div/div[2]/div[1]/span/*[name()='svg']/*[name()='title']")
```
Для определения текста вложенных элементов можно использовать метод `getAttribute("innerHTML")`:
```
p.originalDataChangedTitle.should(Condition.match(
        " the description of the predicate",
        element -> "Исходные данные были изменены".equals(element.getAttribute("innerHTML")))
);
```
